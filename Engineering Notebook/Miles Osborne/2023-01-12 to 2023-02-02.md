# Intro
Instead of having dedicated entries for each day, I think it would be easier to summarize and recount the events during this period given they were targeted towards the same goal. The point of the last few days was working on the actual implementation of the system. Also, I had been full speed in order to make sure we met our deadline and didn't sleep much so some days are kind of a blur.   The trials are to begin at the end of the month and the system must be operational by then. This includes basic hardware controls, data acquisition, and interfacing with the remote device. While I would love to say that it went all to plan, there were unforeseen difficulties. 

## Software Changes
Writing the software was simple for the most part but it did take some time. I modeled the system with a typically super loop and state machine. Due to the limited time, I didn't want to write something more complex which could lead to more issues while testing. Furthermore, the device does not have extremely strict timing or request deadlines so a simple yet slightly inefficient approach is acceptable. The easiest way to remedy this is increase the clock speed of our system by acquiring a faster development board/microcontroller. We will come back to this item later. At the very least establishing the framework for the system was not hard. The only thing that I needed to do was add in the tasks during each task. Admittedly, it's not the best code but it does work and is readable. 

## Acquiring Estimate Motor Speed values
As far as implementing the code for controlling the motor, I had to do a bit of estimation which ultimately ended up being slightly wrong. We were provided a library for controlling the motor in the chair but the actual implementation designates a speed value on a range of -3200 to 3200 where -3200 is full speed in one direction and 3200 is full speed in the other.  However, full speed isn't a good metric to go by and fails to validate our requirement that we do not speed faster than 19 rpm per minute. Since we only need to spin in one direction and took some samples of the motor at different speed settings. I initially tested it at 25%, 50%, 75%, and 100% speed. For 60 seconds, I counted the number of revolutions and got a rough estimate of the speed. Apart from the human error introduced I found that the values were roughly linear. 

Half speed: 17.5 revolutions per minute
Full speed: ~42 (41.75ish) revolutions per minute
75% speed: 29.5 revolutions per minute
25% speed: 3.75 rpm

This feature made it easy to map the potentiometer value to the RPM value that the proctor wants to set. I added a higher resistance potentiometer and 0.1Î¼F capacitor to get rid of much of the analog noise and sensitivity. 

**NOTE**: On recount and looking back at data files, I found that I did this on **Saturday January 21st** 

The problem with this method however, is that it assumes a "best case" scenario. There was no load or person sitting in the chair. Essentially, it takes less power for it spin at 14 rpm if there is no one sitting in the chair. The opposite is also true where it takes more power for it to spin at the set speed if the person or object is heavier. However, our code does not currently adjust to the person's weight. For our system, a heavier load will only cause the person to spin at a slower than desired speed. We were aware of this phenomenon for awhile but saw it in person after we initially moved the chair to the high altitude lab. For example, I weigh roughly 130 lbs (I'm the lightest person on our team) but Kent who is closer to 200lbs would not spin at the same rate if the speed setting were the same for the both of us. Dr. French has not expressed to much concern over this for now but we will likely have to return to this after Brandon can successfully analyze and interpret data from the tachometer

# Remote Connectivity
This is where many of the issues stem from and is the weakest part of our project. Because we need to source data from the person in the chair who is spinning around, we can't rely on wired communication protocols. The original plan was to use Bluetooth but Brandon had in foresight, put 433MHZ radio transceivers/receivers on the budget. Initially this seemed like a good thing give the lack of time we had but ultimately it because the biggest pain of this entire project partially because I spent the most time debugging it. Furthermore, the communication method was only one way, not bi-directional which can come back to bite us later when we need to sync data between modules. The code for the system was simple to implement but after isolated tests that we did it went all downhill. When we put it in the 3D printed enclosure (which wasn't very accommodating to begin with) data was being lost on multiple occasions. I switched microcontrollers/development boards and soldererd the whole thing over again for it to work one hour and then not at all the next. I don't remember why but I somehow had the intuition to isolate the possibility that it was a connection issue. To isolate, I desoldered the horizontal pin headers and then directly soldered wires to the board. We also added another transmitter to the remote modules which seem to prevented the random loss of packets but I'm not particularly convinced. Still, as long as it works, then that is all that matters but there is a unanimous agreement that these modules are going to be replaced during the next sprint. 

## New Boards and Bluetooth
On **January 26**, I did have time to research into wireless communication protocols. I had never done too much work involving telemetry so this was an interesting experience. I started looking into the specifications of the Bluetooth protocol and found that there are two types of Bluetooth connections: classic and low energy (BLE, LE). I don't know all the specifics between the two but the capabilities of both will suffice for our project although it seems like BLE is more common currently. One thing I did make sure of is the directionality of the data transfer. Thankfully, Bluetooth is bi-directional where the host/master or slave can transmit and receive data. The only problem is time stamping/syncing the data between modules. Luckily, there is a reference book in the library titled *The Embedded Systems Handbook* by Richard Zurawski which has a section on time syncing for wireless communication protocols. The book is somewhat old so there may also be newer ways of implementing that aspect of it. 

As stated above, the original plan was to use the bluetooth protocol but more specifically we were going to use the bluetooth module on the Nucleo WB55RG development board. The STM development boards offer a more traditional embedded software/systems environment which gives us alot of control over our project, more than we will ever need. While I am partial to nucleo and STM boards, I decided to look for alternatives. This is for a few reasons:
1. I am the only one our project (apart from Aaron who isn't a member) who has experience with embedded systems and software greater than just an Arduino. 
2. I don't want to introduce complexity into our system just to give myself a challenge especially when people are depending on this device to work. 
3. Our existing code is written using the Arduino framework (due to a hardware failure which I caused breaking one of our original boards)

With that said I needed a board that was compatible with the Arduino framework, compatible with our current system and its components, has a small footprint, preferably had a wireless communication peripheral built in or easily integrates with one, and is preferably faster. After a little bit of searching I stumbled across the a few boards based on the ESP32 MCU and a Cortex M4F. Most notable were the [Feather S3](https://esp32s3.com/feathers3.html) , [Adafruit HUZZAH32](https://www.adafruit.com/product/3405), and the [Adafruit Feather nRF52840 Express](https://www.adafruit.com/product/4062). While the Feather S3 and Huzzah32 were more powerful and seemed to have the greater feature set, I opted to go for the Adafruit Feather nRF52840 express. In embedded software/system development, a very easy mistake to make is to go with the option that has the best of x attribute. For instance the fastest processor or clock speed. That is a terrible design and decision making philosophy for this particular area because you often can introduce more issues by following that rule. The Feather S3 was the newest if memory serves but the least documented. If any issues were to occur (which they probably would), then we would effectively be alone in solving them which then means I'm pretty much alone solving them. The Huzzah32 had the most powerful processor and the best specs but was still under development and was not entirely stable. That last bit is especially important as it pertains to compatibility with the rest of our system. That left the adafruit feather nRF52840 which while the weakest, was still 4 times stronger than our Arduino Mega that we were currently using and well documented to support the Arduino framework. It had a dedicated bluetooth module built in supporting both classic and LE modes and was not terribly expensive either. I think it is cheaper than a genuine Arduino Mega which is surprising.

## Feedback from High Altitude Trials
We began the trials on January 24th which did not start off amazing. The biggest issue being the remote connectivity. Data was being lost on multiple runs for one reason or the other. That said, the actual hardware control of the chair worked correctly. I ended up writing a simple data acquisition script using Python & Pyserial to log the data on one of Dr. French's laptops as a csv file which worked well. 

Two students have been responsible for operating our system during the trials thus far, Kalen and Phillip. I've been communicating with them to try to make the system easier to use. I understand how the system works but what an engineer perceives as easy may not appear that way to someone else. Both of them expressed the need for more visual indicators and feedback when certain events were occurring or complete such as when the remote is connected or the data has successfully been stored. I thought this was fair so I  made some adjustments to the program to better indicate the state of the system. Otherwise, I have been present for all the trials thus far providing tech support (and moral support) when operating the chair. While I cannot be inside the chamber during the experiment, we can communicate still since the chamber walls are clear. We have been using hand gestures and writing notes when there are any issues during the trial. It's not every day that you can see a high altitude indoctrination tests and its great to see our system being used.

Outside of the trials I have been involved in some discussion to make sense of the data collected. Towards the end of the month the data seemed to be getting more accurate, which is leading to some contradiction from the visual results recorded by the observers standing by during the trials. I can't say what the cause of the discrepancy is yet but I figured the best way is to gather more reliable data by improving our hardware. 

In a similar vein, Dr. French asked that we record the time when the chair reaches a complete stop. We can't do this given our current capability since Brandon is still working with the tachometer. However, we can have the proctor mark the timestamp by pressing one of the buttons on the controller module. Given the recent changes, I need to find time to update our documentation to include this new additions. 

A common complain however are the quality of the enclosure for the remote and the buttons we used. The enclosure we build is too shallow for all our hardware without tightly wrapping all of the wires. It also does not close completely and some of the wires are exposed which is not a pretty sight. The buttons we used are without a doubt cheap and have to be completed pressed in order to record a value. There might also be some misreads we those as well. 

## Final Words
As the sprint comes to an end, I can say that we achieved our objective. That said, I found it kinda unfair that I did most of the work. Yes the other members contributed but I can confidently say that I have spend the most time working on this project both from a management and technical perspective. Furthermore, I am the only member at the time of writing who has showed up to the high altitude lab trials. This may be due to schedule conflicts but its evident that I am putting in the most effort regardless but that has its consequences. I can understand additional responsibility for being the scrum master and what is effectively the team lead but at a certain point it is too much. I ended up having to cancel the February launch for a project that I am leading which felt awful. For the next sprint, I do plan on making it more dependent on the other member's contributions. This project cannot live or die based on the effort of one person. 

